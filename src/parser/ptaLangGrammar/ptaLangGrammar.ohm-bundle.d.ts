// AUTOGENERATED FILE
// This file was generated from ptaLangGrammar.ohm by `ohm generateBundles`.

import {
  BaseActionDict,
  Grammar,
  IterationNode,
  Node,
  NonterminalNode,
  Semantics,
  TerminalNode
} from 'ohm-js';

export interface PTALangActionDict<T> extends BaseActionDict<T> {
  Query?: (this: NonterminalNode, arg0: NonterminalNode, arg1: IterationNode, arg2: IterationNode) => T;
  FilterClause?: (this: NonterminalNode, arg0: NonterminalNode, arg1: IterationNode, arg2: IterationNode) => T;
  ExcludeClause?: (this: NonterminalNode, arg0: NonterminalNode, arg1: NonterminalNode, arg2: IterationNode, arg3: IterationNode) => T;
  SelectKey?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  FilterKey?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  ExcludeKey?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  Operator?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  BALANCE?: (this: NonterminalNode, arg0: TerminalNode) => T;
  TRANSACTION?: (this: NonterminalNode, arg0: TerminalNode) => T;
  AND?: (this: NonterminalNode, arg0: TerminalNode) => T;
  OR?: (this: NonterminalNode, arg0: TerminalNode) => T;
  ACCOUNT?: (this: NonterminalNode, arg0: TerminalNode) => T;
  DATE?: (this: NonterminalNode, arg0: TerminalNode) => T;
  STRUCTURE?: (this: NonterminalNode, arg0: TerminalNode) => T;
  LIMIT?: (this: NonterminalNode, arg0: TerminalNode) => T;
  ORDER?: (this: NonterminalNode, arg0: TerminalNode) => T;
  HIDE?: (this: NonterminalNode, arg0: TerminalNode) => T;
  DESCRIPTION?: (this: NonterminalNode, arg0: TerminalNode) => T;
  EXCLUDE?: (this: NonterminalNode, arg0: TerminalNode) => T;
  identifier?: (this: NonterminalNode, arg0: IterationNode) => T;
  string?: (this: NonterminalNode, arg0: TerminalNode, arg1: IterationNode, arg2: TerminalNode) => T;
  number?: (this: NonterminalNode, arg0: IterationNode) => T;
  eq?: (this: NonterminalNode, arg0: TerminalNode) => T;
  neq?: (this: NonterminalNode, arg0: TerminalNode) => T;
  lt?: (this: NonterminalNode, arg0: TerminalNode) => T;
  gt?: (this: NonterminalNode, arg0: TerminalNode) => T;
  lte?: (this: NonterminalNode, arg0: TerminalNode) => T;
  gte?: (this: NonterminalNode, arg0: TerminalNode) => T;
  multiple?: (this: NonterminalNode, arg0: TerminalNode) => T;
  exclude?: (this: NonterminalNode, arg0: TerminalNode) => T;
  current?: (this: NonterminalNode, arg0: TerminalNode) => T;
  last?: (this: NonterminalNode, arg0: TerminalNode) => T;
  first?: (this: NonterminalNode, arg0: TerminalNode) => T;
  range?: (this: NonterminalNode, arg0: TerminalNode) => T;
  desc?: (this: NonterminalNode, arg0: TerminalNode) => T;
  asc?: (this: NonterminalNode, arg0: TerminalNode) => T;
  comma?: (this: NonterminalNode, arg0: TerminalNode) => T;
  colon?: (this: NonterminalNode, arg0: TerminalNode) => T;
  semicolon?: (this: NonterminalNode, arg0: TerminalNode) => T;
  newline?: (this: NonterminalNode, arg0: TerminalNode) => T;
}

export interface PTALangSemantics extends Semantics {
  addOperation<T>(name: string, actionDict: PTALangActionDict<T>): this;
  extendOperation<T>(name: string, actionDict: PTALangActionDict<T>): this;
  addAttribute<T>(name: string, actionDict: PTALangActionDict<T>): this;
  extendAttribute<T>(name: string, actionDict: PTALangActionDict<T>): this;
}

export interface PTALangGrammar extends Grammar {
  createSemantics(): PTALangSemantics;
  extendSemantics(superSemantics: PTALangSemantics): PTALangSemantics;
}

declare const grammar: PTALangGrammar;
export default grammar;

